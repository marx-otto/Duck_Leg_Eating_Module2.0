using UnityEngine;
using System.Collections;
using System.Reflection;

namespace Duck_Leg_Eating_Module
{
    public class ModBehaviour : Duckov.Modding.ModBehaviour
    {
        private void Start()
        {
            Debug.Log("鸭腿食用模块已加载 - 只能食用敌人鸭腿");
            
            // 订阅容器打开事件
            InteractableLootbox.OnStartLoot += OnLootboxOpened;
        }

        private void OnLootboxOpened(InteractableLootbox lootbox)
        {
            // 检查是否是敌人鸭腿（通过名称判断）
            if (IsEnemyCorpse(lootbox))
            {
                // 当敌人鸭腿被打开时，开始检查它是否为空
                StartCoroutine(CheckIfCorpseBecomesEmpty(lootbox));
            }
        }

        private bool IsEnemyCorpse(InteractableLootbox lootbox)
        {
            // 通过名称判断是否是敌人鸭腿
            string lootboxName = lootbox.name.ToLower();
            return lootboxName.Contains("corpse") || lootboxName.Contains("body") || lootboxName.Contains("enemy") || 
                   lootboxName.Contains("scav") || lootboxName.Contains("鸭腿") || lootboxName.Contains("敌人");
        }

        private IEnumerator CheckIfCorpseBecomesEmpty(InteractableLootbox corpse)
        {
            // 立即开始检查，不等待
            while (corpse != null && corpse.Inventory != null)
            {
                if (corpse.Inventory.IsEmpty())
                {
                    // 鸭腿为空，添加食用功能
                    var existingEatable = corpse.GetComponent<EatableCorpse>();
                    if (existingEatable == null)
                    {
                        var eatable = corpse.gameObject.AddComponent<EatableCorpse>();
                        eatable.Initialize(corpse);
                        Debug.Log($"敌人鸭腿 {corpse.name} 已空，可以食用");
                    }
                    yield break; // 停止检查
                }
                
                // 每0.1秒检查一次，更快响应
                yield return new WaitForSeconds(0.1f);
            }
        }

        private void OnDestroy()
        {
            // 取消订阅事件
            InteractableLootbox.OnStartLoot -= OnLootboxOpened;
            Debug.Log("鸭腿食用模块已卸载");
        }
    }

    public class EatableCorpse : MonoBehaviour
    {
        private InteractableLootbox _corpse;
        private CharacterMainControl _player;
        private bool _isEatable = true;
        private bool _isShowingPrompt;
        private bool _isCarried;
        private EnemyType _enemyType;
        private bool _isReleasing;

        private enum EnemyType
        {
            Normal,
            Minion,  
            Boss
        }

        public void Initialize(InteractableLootbox targetCorpse)
        {
            _corpse = targetCorpse;
            
            _enemyType = GetEnemyType(_corpse);
            Debug.Log($"识别到敌人类型: {_enemyType} - {_corpse.name}");
            
            CheckIfCarried();
        }

        private EnemyType GetEnemyType(InteractableLootbox lootbox)
        {
            EnemyType typeFromPreset = TryGetEnemyTypeFromPreset();
            if (typeFromPreset != EnemyType.Normal)
                return typeFromPreset;

            return GetEnemyTypeFromLootbox(lootbox);
        }

        private EnemyType TryGetEnemyTypeFromPreset()
        {
            return EnemyType.Normal;
        }

        private EnemyType GetEnemyTypeFromLootbox(InteractableLootbox lootbox)
        {
            string lootboxName = lootbox.name.ToLower();
            
            if (lootboxName.Contains("boss"))
                return EnemyType.Boss;
            if (lootboxName.Contains("elite") || lootboxName.Contains("miniboss") || 
                lootboxName.Contains("minion") || lootboxName.Contains("小弟") || lootboxName.Contains("精英"))
                return EnemyType.Minion;
            
            return EnemyType.Normal;
        }

        private void Update()
        {
            if (!_isEatable || _corpse == null) return;
            
            if (!_isCarried)
            {
                CheckIfCarried();
                return;
            }
            
            if (_player == null)
            {
                _player = FindObjectOfType<CharacterMainControl>();
                if (_player == null) return;
            }

            if (_isReleasing) return;

            if (_isCarried)
            {
                if (!_isShowingPrompt)
                {
                    _player.PopText("按 E 开饭", 2f);
                    _isShowingPrompt = true;
                }
                
                if (Input.GetKeyDown(KeyCode.E))
                {
                    Debug.Log("检测到E键按下，尝试食用鸭腿");
                    EatCorpse();
                }
            }
        }

        private void CheckIfCarried()
        {
            if (_corpse.transform.parent != null)
            {
                var parentPlayer = _corpse.transform.parent.GetComponentInParent<CharacterMainControl>();
                if (parentPlayer != null)
                {
                    _isCarried = true;
                    _player = parentPlayer;
                    Debug.Log($"鸭腿被玩家搬起，可以食用");
                }
            }
        }

        private void EatCorpse()
        {
            if (!_isEatable || _isReleasing) return;
            
            Debug.Log($"开始执行食用{_enemyType}鸭腿逻辑");
            
            if (_player == null)
            {
                _player = FindObjectOfType<CharacterMainControl>();
                if (_player == null)
                {
                    Debug.LogError("找不到玩家");
                    return;
                }
            }

            ApplyEffectsBasedOnEnemyType(_enemyType);
            
            _isReleasing = true;
            StartCoroutine(ReleaseAndDestroyCoroutine());
            
            _isEatable = false;
        }

        private IEnumerator ReleaseAndDestroyCoroutine()
        {
            Debug.Log("开始释放和销毁流程");

            bool success = DirectSimulateFKey();
            if (success)
            {
                Debug.Log("成功模拟F键交互");
                yield return null;
            }
            else
            {
                Debug.LogWarning("模拟F键失败，使用备用方案");
                TryStopCarryActionDirectly();
                yield return null;
            }

            // 新增：尝试切换到一号武器
            Debug.Log("开始尝试切换到一号武器");
            yield return StartCoroutine(TrySwitchToWeapon1Coroutine());

            ForceCleanupAndDestroy();

            _isReleasing = false;
        }

        /// <summary>
        /// 尝试切换到一号武器的协程
        /// </summary>
        private IEnumerator TrySwitchToWeapon1Coroutine()
        {
            Debug.Log("尝试切换到一号武器");
            
            // 等待一小段时间确保放下动作完成
            yield return new WaitForSeconds(0.3f);
            
            // 方法1: 通过输入系统模拟按下数字键1
            Debug.Log("尝试方法1: 通过输入系统模拟按下数字键1");
            if (SimulateNumber1Key())
            {
                Debug.Log("成功通过输入系统切换到一号武器");
                yield break;
            }

            // 方法2: 直接调用武器切换方法
            Debug.Log("尝试方法2: 直接调用武器切换方法");
            if (TryDirectWeaponSwitch())
            {
                Debug.Log("成功直接切换到一号武器");
                yield break;
            }

            // 方法3: 通过快捷键系统
            Debug.Log("尝试方法3: 通过快捷键系统");
            if (TryShortcutSwitch())
            {
                Debug.Log("成功通过快捷键系统切换到一号武器");
                yield break;
            }

            // 方法4: 直接模拟按键1
            Debug.Log("尝试方法4: 直接模拟按键1");
            if (SimulateKey1Press())
            {
                Debug.Log("成功通过模拟按键1切换到一号武器");
                yield break;
            }

            Debug.LogWarning("所有切换武器的方法都失败了");
        }

        /// <summary>
        /// 方法1: 通过输入系统模拟按下数字键1
        /// </summary>
        private bool SimulateNumber1Key()
        {
            try
            {
                // 查找InputManager并调用数字键1的处理方法
                System.Type inputManagerType = System.Type.GetType("InputManager, Assembly-CSharp");
                if (inputManagerType != null)
                {
                    var instanceProperty = inputManagerType.GetProperty("Instance", BindingFlags.Public | BindingFlags.Static);
                    if (instanceProperty != null)
                    {
                        var inputManager = instanceProperty.GetValue(null);
                        if (inputManager != null)
                        {
                            // 尝试调用快捷键方法
                            var shortcutMethod = inputManagerType.GetMethod("OnShortcutInput", BindingFlags.Public | BindingFlags.Instance);
                            if (shortcutMethod != null)
                            {
                                // 数字键1通常对应快捷键索引0
                                shortcutMethod.Invoke(inputManager, new object[] { 0 });
                                Debug.Log("成功调用OnShortcutInput(0)");
                                return true;
                            }

                            // 尝试调用武器切换方法
                            var weaponSwitchMethod = inputManagerType.GetMethod("SwitchToWeapon1", BindingFlags.Public | BindingFlags.Instance);
                            if (weaponSwitchMethod != null)
                            {
                                weaponSwitchMethod.Invoke(inputManager, null);
                                Debug.Log("成功调用SwitchToWeapon1");
                                return true;
                            }

                            // 尝试调用通用的武器切换方法
                            var switchWeaponMethod = inputManagerType.GetMethod("SwitchToWeapon", BindingFlags.Public | BindingFlags.Instance);
                            if (switchWeaponMethod != null)
                            {
                                switchWeaponMethod.Invoke(inputManager, new object[] { 0 });
                                Debug.Log("成功调用SwitchToWeapon(0)");
                                return true;
                            }
                        }
                    }
                }

                return false;
            }
            catch (System.Exception e)
            {
                Debug.LogWarning($"通过输入系统模拟数字键1失败: {e.Message}");
                return false;
            }
        }

        /// <summary>
        /// 方法2: 直接调用武器切换方法
        /// </summary>
        private bool TryDirectWeaponSwitch()
        {
            try
            {
                if (_player == null) 
                {
                    Debug.LogWarning("玩家为空，无法切换武器");
                    return false;
                }

                // 尝试调用玩家的武器切换方法
                var switchWeaponMethod = _player.GetType().GetMethod("SwitchToWeapon", BindingFlags.Public | BindingFlags.Instance);
                if (switchWeaponMethod != null)
                {
                    // 尝试切换到第一个武器槽（索引0）
                    switchWeaponMethod.Invoke(_player, new object[] { 0 });
                    Debug.Log("成功调用玩家SwitchToWeapon(0)");
                    return true;
                }

                // 尝试调用装备武器方法
                var equipWeaponMethod = _player.GetType().GetMethod("EquipWeapon", BindingFlags.Public | BindingFlags.Instance);
                if (equipWeaponMethod != null)
                {
                    equipWeaponMethod.Invoke(_player, new object[] { 0 });
                    Debug.Log("成功调用玩家EquipWeapon(0)");
                    return true;
                }

                // 尝试调用切换武器槽方法
                var switchSlotMethod = _player.GetType().GetMethod("SwitchToSlot", BindingFlags.Public | BindingFlags.Instance);
                if (switchSlotMethod != null)
                {
                    switchSlotMethod.Invoke(_player, new object[] { 0 });
                    Debug.Log("成功调用玩家SwitchToSlot(0)");
                    return true;
                }

                return false;
            }
            catch (System.Exception e)
            {
                Debug.LogWarning($"直接切换武器失败: {e.Message}");
                return false;
            }
        }

        /// <summary>
        /// 方法3: 通过快捷键系统
        /// </summary>
        private bool TryShortcutSwitch()
        {
            try
            {
                // 尝试查找快捷键系统
                System.Type shortcutManagerType = System.Type.GetType("ShortcutManager, Assembly-CSharp");
                if (shortcutManagerType != null)
                {
                    var instanceProperty = shortcutManagerType.GetProperty("Instance", BindingFlags.Public | BindingFlags.Static);
                    if (instanceProperty != null)
                    {
                        var shortcutManager = instanceProperty.GetValue(null);
                        if (shortcutManager != null)
                        {
                            var useShortcutMethod = shortcutManagerType.GetMethod("UseShortcut", BindingFlags.Public | BindingFlags.Instance);
                            if (useShortcutMethod != null)
                            {
                                useShortcutMethod.Invoke(shortcutManager, new object[] { 0 }); // 第一个快捷键
                                Debug.Log("成功调用UseShortcut(0)");
                                return true;
                            }
                        }
                    }
                }

                return false;
            }
            catch (System.Exception e)
            {
                Debug.LogWarning($"通过快捷键系统切换武器失败: {e.Message}");
                return false;
            }
        }

        /// <summary>
        /// 方法4: 直接模拟按键1
        /// </summary>
        private bool SimulateKey1Press()
        {
            try
            {
                // 使用InputSystem模拟按键
                var inputActionType = System.Type.GetType("UnityEngine.InputSystem.InputAction, UnityEngine.InputSystem");
                if (inputActionType != null)
                {
                    // 尝试查找玩家输入组件
                    var playerInputType = System.Type.GetType("UnityEngine.InputSystem.PlayerInput, UnityEngine.InputSystem");
                    if (playerInputType != null)
                    {
                        var playerInput = _player.GetComponent(playerInputType);
                        if (playerInput != null)
                        {
                            // 尝试触发数字键1的动作
                            var actionMapProperty = playerInputType.GetProperty("currentActionMap", BindingFlags.Public | BindingFlags.Instance);
                            if (actionMapProperty != null)
                            {
                                var actionMap = actionMapProperty.GetValue(playerInput);
                                if (actionMap != null)
                                {
                                    var findActionMethod = actionMap.GetType().GetMethod("FindAction", new[] { typeof(string) });
                                    if (findActionMethod != null)
                                    {
                                        var action = findActionMethod.Invoke(actionMap, new object[] { "Shortcut1" });
                                        if (action != null)
                                        {
                                            var triggerMethod = action.GetType().GetMethod("Trigger");
                                            if (triggerMethod != null)
                                            {
                                                triggerMethod.Invoke(action, null);
                                                Debug.Log("成功触发Shortcut1动作");
                                                return true;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // 备选方案：直接使用Unity的Input系统
                Debug.Log("尝试使用备选方案：直接模拟按键1");
                // 这里可以添加直接模拟按键的代码
                // 但由于Unity的限制，直接模拟按键比较复杂

                return false;
            }
            catch (System.Exception e)
            {
                Debug.LogWarning($"直接模拟按键1失败: {e.Message}");
                return false;
            }
        }

        private bool DirectSimulateFKey()
        {
            try
            {
                Debug.Log("尝试直接模拟F键交互");

                // 方法1: 查找InputManager并直接调用Interact
                System.Type inputManagerType = System.Type.GetType("InputManager, Assembly-CSharp");
                if (inputManagerType != null)
                {
                    var instanceProperty = inputManagerType.GetProperty("Instance", BindingFlags.Public | BindingFlags.Static);
                    if (instanceProperty != null)
                    {
                        var inputManager = instanceProperty.GetValue(null);
                        if (inputManager != null)
                        {
                            // 获取所有名为"Interact"的方法
                            var interactMethods = inputManagerType.GetMethods(BindingFlags.Public | BindingFlags.Instance);
                            
                            // 手动查找无参数的方法
                            MethodInfo interactMethod = null;
                            foreach (var method in interactMethods)
                            {
                                if (method.Name == "Interact" && method.GetParameters().Length == 0)
                                {
                                    interactMethod = method;
                                    break;
                                }
                            }
                            
                            if (interactMethod != null)
                            {
                                interactMethod.Invoke(inputManager, null);
                                Debug.Log("成功调用InputManager.Interact");
                                return true;
                            }
                            else
                            {
                                // 如果没有无参数的方法，尝试调用第一个名为Interact的方法
                                foreach (var method in interactMethods)
                                {
                                    if (method.Name == "Interact")
                                    {
                                        method.Invoke(inputManager, null);
                                        Debug.Log("成功调用InputManager.Interact（第一个匹配的方法）");
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }

                // 方法2: 直接调用玩家的Interact方法（处理重载问题）
                var playerInteractMethods = _player.GetType().GetMethods(BindingFlags.Public | BindingFlags.Instance);
                
                // 手动查找无参数的方法
                MethodInfo playerInteractMethod = null;
                foreach (var method in playerInteractMethods)
                {
                    if (method.Name == "Interact" && method.GetParameters().Length == 0)
                    {
                        playerInteractMethod = method;
                        break;
                    }
                }
                
                if (playerInteractMethod != null)
                {
                    playerInteractMethod.Invoke(_player, null);
                    Debug.Log("成功调用玩家Interact方法");
                    return true;
                }
                else
                {
                    // 如果没有无参数的方法，尝试调用第一个名为Interact的方法
                    foreach (var method in playerInteractMethods)
                    {
                        if (method.Name == "Interact")
                        {
                            method.Invoke(_player, null);
                            Debug.Log("成功调用玩家Interact（第一个匹配的方法）");
                            return true;
                        }
                    }
                }

                // 方法3: 通过InputSystem直接发送F键按下事件
                return SimulateFKeyThroughInputSystem();
            }
            catch (System.Exception e)
            {
                Debug.LogError($"直接模拟F键失败: {e.Message}");
                return false;
            }
        }

        private bool SimulateFKeyThroughInputSystem()
        {
            try
            {
                // 使用Unity的InputSystem直接模拟按键
                System.Type inputSystemType = System.Type.GetType("UnityEngine.InputSystem.InputSystem, UnityEngine.InputSystem");
                if (inputSystemType != null)
                {
                    // 查找Keyboard.current
                    System.Type keyboardType = System.Type.GetType("UnityEngine.InputSystem.Keyboard, UnityEngine.InputSystem");
                    var currentProperty = keyboardType?.GetProperty("current", BindingFlags.Public | BindingFlags.Static);
                    var keyboard = currentProperty?.GetValue(null);
                    
                    if (keyboard != null)
                    {
                        // 查找f键
                        var fKeyProperty = keyboardType.GetProperty("fKey");
                        var fKey = fKeyProperty?.GetValue(keyboard);
                        
                        if (fKey != null)
                        {
                            // 直接调用QueueEvent方法
                            var queueEventMethod = inputSystemType.GetMethod("QueueEvent");
                            if (queueEventMethod != null)
                            {
                                Debug.Log("找到InputSystem但实现较复杂，跳过");
                            }
                        }
                    }
                }
                
                return false;
            }
            catch (System.Exception e)
            {
                Debug.LogWarning($"通过InputSystem模拟F键失败: {e.Message}");
                return false;
            }
        }

        private void TryStopCarryActionDirectly()
        {
            try
            {
                Debug.Log("尝试直接停止搬运动作");

                // 查找CA_Carry组件
                System.Type carryActionType = System.Type.GetType("CA_Carry, Assembly-CSharp");
                if (carryActionType != null)
                {
                    var carryComponent = _player.GetComponent(carryActionType);
                    if (carryComponent != null)
                    {
                        var onStopMethod = carryActionType.GetMethod("OnStop", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
                        if (onStopMethod != null)
                        {
                            onStopMethod.Invoke(carryComponent, null);
                            Debug.Log("成功调用CA_Carry.OnStop");
                            return;
                        }
                    }
                }

                // 查找Carriable组件
                System.Type carriableType = System.Type.GetType("Carriable, Assembly-CSharp");
                if (carriableType != null)
                {
                    var carriableComponent = _player.GetComponent(carriableType);
                    if (carriableComponent != null)
                    {
                        var dropMethod = carriableType.GetMethod("Drop", BindingFlags.Public | BindingFlags.Instance);
                        if (dropMethod != null)
                        {
                            dropMethod.Invoke(carriableComponent, null);
                            Debug.Log("成功调用Carriable.Drop");
                            return;
                        }
                    }
                }

                // 最后尝试通过StopAction停止当前动作
                var stopActionMethod = _player.GetType().GetMethod("StopAction", BindingFlags.Public | BindingFlags.Instance);
                if (stopActionMethod != null)
                {
                    stopActionMethod.Invoke(_player, null);
                    Debug.Log("成功调用StopAction");
                }
            }
            catch (System.Exception e)
            {
                Debug.LogWarning($"直接停止搬运动作失败: {e.Message}");
            }
        }

        private void ForceCleanupAndDestroy()
        {
            Debug.Log("执行强制清理");

            TryStopCarryActionDirectly();

            if (_corpse != null && _corpse.transform.parent != null)
            {
                _corpse.transform.SetParent(null);
                Debug.Log("解除父子关系");
            }

            var colliders = _corpse.GetComponentsInChildren<Collider>();
            foreach (var collider in colliders)
            {
                collider.enabled = false;
            }

            var renderers = _corpse.GetComponentsInChildren<Renderer>();
            foreach (var renderer in renderers)
            {
                renderer.enabled = false;
            }

            if (_corpse != null)
            {
                Destroy(_corpse.gameObject);
                Debug.Log("鸭腿已销毁");
            }
        }

        private void ApplyEffectsBasedOnEnemyType(EnemyType type)
        {
            float healthRestore = 0f;
            float energyRestore = 0f;
            float waterRestore = 0f;
            string message = "";

            switch (type)
            {
                case EnemyType.Normal:
                    healthRestore = 20f;
                    energyRestore = 40f;
                    waterRestore = 40f;
                    message = "嘎嘎好吃";
                    break;
                    
                case EnemyType.Minion:
                    healthRestore = 40f;
                    energyRestore = 60f;
                    waterRestore = 60f;
                    message = "我感受到了力量";
                    break;
                    
                case EnemyType.Boss:
                    healthRestore = 40f;
                    energyRestore = 60f;
                    waterRestore = 60f;
                    message = "没人能阻挡我！";
                    break;
            }

            ApplyRestorationEffects(healthRestore, energyRestore, waterRestore, message);
            
            Debug.Log($"食用{type}鸭腿，恢复{healthRestore}生命, {energyRestore}饱食度, {waterRestore}水分");
        }

        private void ApplyRestorationEffects(float health, float energy, float water, string message)
        {
            if (_player.Health != null)
            {
                _player.Health.AddHealth(health);
                Debug.Log($"成功恢复{health}点生命值");
            }
            else
            {
                Debug.LogError("无法获取玩家Health组件");
            }

            if (_player.MaxEnergy > 0)
            {
                _player.CurrentEnergy = Mathf.Min(_player.CurrentEnergy + energy, _player.MaxEnergy);
                Debug.Log($"成功恢复{energy}点饱食度");
            }
            else
            {
                Debug.LogWarning("玩家饱食度系统不可用");
            }

            TryAddWater(water);

            _player.PopText(message, 3f);
        }

        private void TryAddWater(float amount)
        {
            var addWaterMethod = _player.GetType().GetMethod("AddWater");
            if (addWaterMethod != null)
            {
                addWaterMethod.Invoke(_player, new object[] { amount });
                Debug.Log($"成功恢复{amount}点水分");
                return;
            }

            var fillComponent = _player.GetComponent<FillWaterAndFood>();
            if (fillComponent != null)
            {
                var fillMethod = fillComponent.GetType().GetMethod("Fill");
                if (fillMethod != null)
                {
                    fillMethod.Invoke(fillComponent, null);
                    Debug.Log($"通过FillWaterAndFood恢复水分");
                    return;
                }
            }

            var waterProperty = _player.GetType().GetProperty("CurrentWater");
            if (waterProperty != null && waterProperty.CanWrite)
            {
                float currentWater = (float)waterProperty.GetValue(_player);
                float maxWater = GetMaxWater(_player);
                waterProperty.SetValue(_player, Mathf.Min(currentWater + amount, maxWater));
                Debug.Log($"直接设置水分属性，恢复{amount}点水分");
                return;
            }

            Debug.LogWarning("无法找到水分恢复方法，水分恢复失败");
        }

        private float GetMaxWater(CharacterMainControl character)
        {
            var maxWaterProperty = character.GetType().GetProperty("MaxWater");
            if (maxWaterProperty != null)
            {
                return (float)maxWaterProperty.GetValue(character);
            }
            return 100f;
        }
    }
}